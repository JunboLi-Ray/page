锁

linux锁阻塞线程方法：pthread_mutex_lock
futex同步源语，先用户spin再内核阻塞

锁优化：
自旋锁 自适应旋锁（等一会不阻塞，代码层面）。
锁消除（不逃逸，既不会被其他线程访问，无竞争去掉锁）。
锁粗化（同一个部分来回加锁，扩大至外面，jvm层面）。
轻量级锁（通过CAS改变对象的头mark word，若有占用且不是自己则变重量级锁。jvm层面）。
偏向锁（若一个对象使用cas调用一次锁后，别人不再用此对象，则此线程以后再也不执行cas加锁去锁过程）。


机制：
cas：对比和设置。
aqs：异步队列，语言层面（jvm也有），把请求锁的线程排队。


锁方式：
synchronized ：
jvm层面，锁对象或类文件，抢mark头。
先偏向锁，认为不会变成其它线程使用。
否则轻量级锁，cas改变，若失败则自旋，若自旋超时加入阻塞队列，即重量锁，应用系统的阻塞方法。
有资源释放锁时，选c队列里的到e队列，减少c队列尾部元素竞争，再把e中某个线程标记为可竞争线程，让他去竞争。（可能和自选锁）

队列：
contentionlist，都先放这里，队头添加。
entrylist，拥有锁的线程上面里选有资格的放这里。
waitset，运行后调wait阻塞的线程。


lock：
代码调用cas类，抢信号量。
偏向实现方式，重入，只改变排它锁的值，+1。
自旋实现方式，排它锁失败，while自旋。自旋失败，加入阻塞队列，调用系统函数，阻塞进程。
非公平锁，失败时自旋，不直接入aqs队列。其它过程都一样。