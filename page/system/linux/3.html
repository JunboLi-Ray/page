内存

* 外部碎片：未分配出去，但过小无法分配给新进程的内存
用伙伴算法解决外部碎片
分为1、2、4、8……等大小的页，释放的，就合并成大的，分配就由小到大找，找到分配并拆分，找不到就异常。
<img>￼

* 内部碎片：已经分配出去，但大于所需的空间
用slab算法解决内部碎片，分配小区域。
按对象存储，如线程描述，会在高速缓存区缓存。
￼
<img>￼

* 内存不够
pera算法在无回收页框，磁盘缓存也被压缩了，没有进程可以执行了，就会选一个进程杀掉。
杀掉的进程，释放的多，影响工作小，不是root，没访问硬件。
内存不足使用交换，将部分磁盘作为内存使用。


* 父进程创建子进程时，采用写时复制。
内核将父进程的页框赋给子进程，只有当某一个进程改变时，才新建一个页框。


* 寻址，muu（内存管理单元）
逻辑地址：段地址和偏移量
线性地址，通过分段机制得到
物理地址，通过分页机制得到
￼
￼<img>￼
<img>￼

* 虚拟地址，每个进程内的内存空间
分页模型：
32位系统，10位（1024个）页目录，10位页表，12位具体页内部的偏移
因此32位系统可以寻4GB大小空间


每个cpu有一个gdt，全局描述符表，每个进程可能还有自己的ldt，局部描述符表。
表里有段地址。

cpu速度是内存的百倍，所以之间有：
硬件高速缓存，存储获取的数据，硬件控制刷新系统不可见。
tlb，转换后援缓冲器，存储线性地址生成的物理地址，系统控制，因为硬件不知道什么时候失效。

连续内存减少内存访问，减少刷新tlb。

* DMA
- DREQ：DMA 请求信号。是外设向 DMA 控制器提出要求，DMA 操作的申请信号
- DACK：DMA 响应信号。是 DMA 控制器向提出 DMA 请求的外设表示已收到请求和正进行处理的信号
- HRQ：DMA 控制器向 CPU 发出的信号，要求接管总线的请求信号。
- HLDA：CPU 向 DMA 控制器发出的信号，允许接管总线的应答信号：
￼
<img>￼
